<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced WebRTC Audio Room</title>
    <style>
        :root {
            --primary: #4da3ff;
            --primary-dark: #3a7bc8;
            --secondary: #3fb27f;
            --dark-bg: #121826;
            --card-bg: #1a2235;
            --card-border: #253044;
            --text-primary: #e6edf3;
            --text-secondary: #9fb0c3;
            --success: #3fb27f;
            --warning: #ff994d;
            --error: #ff4d4d;
            --online: #3fb27f;
            --offline: #9fb0c3;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        body {
            background: var(--dark-bg);
            color: var(--text-primary);
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            line-height: 1.6;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            padding: 20px;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            width: 100%;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px 0;
            border-bottom: 1px solid var(--card-border);
        }

        h1 {
            color: var(--primary);
            margin-bottom: 10px;
            font-size: 2.5rem;
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 1.1rem;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 350px;
            gap: 20px;
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
            }
        }

        .card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 24px;
            box-shadow: 0 8px 32px rgba(0, 0, 0, 0.18);
            margin-bottom: 20px;
        }

        .card-title {
            font-size: 1.3rem;
            margin-bottom: 20px;
            color: var(--primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .card-title svg {
            width: 24px;
            height: 24px;
        }

        .audio-container {
            text-align: center;
            margin-bottom: 25px;
        }

        #remoteAudio {
            width: 100%;
            background: var(--dark-bg);
            border-radius: 12px;
            margin: 15px 0;
        }

        .audio-controls {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
        }

        button {
            background: linear-gradient(90deg, var(--primary), var(--secondary));
            color: white;
            border: none;
            border-radius: 12px;
            padding: 14px 28px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 12px rgba(77, 163, 255, 0.25);
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 16px rgba(77, 163, 255, 0.35);
        }

        button:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
            box-shadow: none;
        }

        button.secondary {
            background: var(--card-border);
        }

        button.danger {
            background: var(--error);
        }

        .status-container {
            display: flex;
            flex-direction: column;
            gap: 15px;
        }

        .status-item {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            background: rgba(37, 48, 68, 0.5);
            border-radius: 12px;
            font-size: 0.95rem;
        }

        .status-icon {
            width: 20px;
            height: 20px;
            margin-right: 12px;
            border-radius: 50%;
            flex-shrink: 0;
        }

        .status-connected {
            background: var(--success);
        }

        .status-connecting {
            background: var(--warning);
            animation: pulse 1.5s infinite;
        }

        .status-disconnected {
            background: var(--error);
        }

        .users-list {
            list-style: none;
            margin-top: 15px;
        }

        .user-item {
            display: flex;
            align-items: center;
            padding: 12px 16px;
            margin-bottom: 10px;
            background: rgba(37, 48, 68, 0.5);
            border-radius: 12px;
            font-size: 0.95rem;
        }

        .user-status {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 12px;
            flex-shrink: 0;
        }

        .user-online {
            background: var(--online);
        }

        .user-offline {
            background: var(--offline);
        }

        .user-you {
            color: var(--primary);
            font-weight: 600;
        }

        .reconnect-container {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 15px;
            background: rgba(255, 77, 77, 0.1);
            border: 1px solid var(--error);
            border-radius: 12px;
            margin-top: 20px;
        }

        .reconnect-text {
            font-size: 0.9rem;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 12px;
            background: var(--card-bg);
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.2);
            transform: translateX(100%);
            opacity: 0;
            transition: all 0.3s ease;
            z-index: 1000;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .notification.show {
            transform: translateX(0);
            opacity: 1;
        }

        .notification-success {
            border-left: 4px solid var(--success);
        }

        .notification-warning {
            border-left: 4px solid var(--warning);
        }

        .notification-error {
            border-left: 4px solid var(--error);
        }

        .notification-icon {
            font-size: 1.2rem;
        }

        @keyframes pulse {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }

            100% {
                opacity: 1;
            }
        }

        .connection-quality {
            height: 6px;
            border-radius: 3px;
            background: var(--card-border);
            margin-top: 8px;
            overflow: hidden;
        }

        .quality-bar {
            height: 100%;
            background: var(--success);
            width: 0%;
            transition: width 0.5s ease;
        }

        footer {
            text-align: center;
            margin-top: 40px;
            padding: 20px 0;
            color: var(--text-secondary);
            font-size: 0.9rem;
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>WebRTC Audio Room</h1>
            <p class="subtitle">High-quality peer-to-peer audio communication</p>
        </header>

        <div class="main-content">
            <div class="left-panel">
                <div class="card">
                    <h2 class="card-title">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M19 11a7 7 0 01-7 7m0 0a7 7 0 01-7-7m7 7v4m0 0H8m4 0h4m-4-8a3 3 0 01-3-3V5a3 3 0 116 0v6a3 3 0 01-3 3z" />
                        </svg>
                        Audio Controls
                    </h2>

                    <div class="audio-container">
                        <audio id="remoteAudio" controls autoplay></audio>
                    </div>

                    <div class="audio-controls">
                        <button id="callBtn">
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                                viewBox="0 0 16 16">
                                <path
                                    d="M3.654 1.328a.678.678 0 0 0-1.015-.063L1.605 2.3c-.483.484-.661 1.169-.45 1.77a17.568 17.568 0 0 0 4.168 6.608 17.569 17.569 0 0 0 6.608 4.168c.601.211 1.286.033 1.77-.45l1.034-1.034a.678.678 0 0 0-.063-1.015l-2.307-1.794a.678.678 0 0 0-.58-.122l-2.19.547a1.745 1.745 0 0 1-1.657-.459L5.482 8.062a1.745 1.745 0 0 1-.46-1.657l.548-2.19a.678.678 0 0 0-.122-.58L3.654 1.328z" />
                            </svg>
                            Call Peer
                        </button>
                        <button id="hangupBtn" disabled>
                            <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                                viewBox="0 0 16 16">
                                <path
                                    d="M3.654 1.328a.678.678 0 0 0-1.015-.063L1.605 2.3c-.483.484-.661 1.169-.45 1.77a17.568 17.568 0 0 0 4.168 6.608 17.569 17.569 0 0 0 6.608 4.168c.601.211 1.286.033 1.77-.45l1.034-1.034a.678.678 0 0 0-.063-1.015l-2.307-1.794a.678.678 0 0 0-.58-.122l-2.19.547a1.745 1.745 0 0 1-1.657-.459L5.482 8.062a1.745 1.745 0 0 1-.46-1.657l.548-2.19a.678.678 0 0 0-.122-.58L3.654 1.328zM11.5 1a.5.5 0 0 1 .5.5v11a.5.5 0 0 1-1 0v-11a.5.5 0 0 1 .5-.5zm-5 0a.5.5 0 0 1 .5.5v11a.5.5 0 0 1-1 0v-11a.5.5 0 0 1 .5-.5z" />
                            </svg>
                            Hang Up
                        </button>
                    </div>

                    <div class="status-container">
                        <div class="status-item">
                            <div class="status-icon" id="connectionStatus"></div>
                            <div>
                                <div>Connection Status: <span id="statusText">Disconnected</span></div>
                                <div class="connection-quality">
                                    <div class="quality-bar" id="qualityBar"></div>
                                </div>
                            </div>
                        </div>

                        <div class="status-item">
                            <div class="status-icon"></div>
                            <div>Room: <strong id="roomName">${roomId}</strong></div>
                        </div>

                        <div class="status-item">
                            <div class="status-icon"></div>
                            <div>User: <strong id="userName">${userName || "Anonymous"}</strong></div>
                        </div>
                    </div>
                </div>

                <div class="card">
                    <h2 class="card-title">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M13 16h-1v-4h-1m1-4h.01M21 12a9 9 0 11-18 0 9 9 0 0118 0z" />
                        </svg>
                        Connection Information
                    </h2>

                    <div id="iceConnectionState">ICE state: new</div>
                    <div id="signalingState">Signaling state: stable</div>
                    <div id="connectionState">Connection state: new</div>
                </div>
            </div>

            <div class="right-panel">
                <div class="card">
                    <h2 class="card-title">
                        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                                d="M17 20h5v-2a3 3 0 00-5.356-1.857M17 20H7m10 0v-2c0-.656-.126-1.283-.356-1.857M7 20H2v-2a3 3 0 015.356-1.857M7 20v-2c0-.656.126-1.283.356-1.857m0 0a5.002 5.002 0 019.288 0M15 7a3 3 0 11-6 0 3 3 0 016 0zm6 3a2 2 0 11-4 0 2 2 0 014 0zM7 10a2 2 0 11-4 0 2 2 0 014 0z" />
                        </svg>
                        Users in Room
                    </h2>

                    <ul class="users-list">
                        <li class="user-item">
                            <div class="user-status user-online"></div>
                            <div class="user-you">You (<span id="yourUserName"></span>)</div>

                        </li>

                    </ul>
                    <ul class="users-list" id="usersList">

                        <li class="user-item">
                            <div class="user-status user-online"></div>
                            <div class="user-you">Other (<span id="otherUserName"></span>)</div>

                        </li>
                    </ul>
                </div>

                <div id="reconnectPanel" class="reconnect-container" style="display: none;">
                    <div class="reconnect-text">
                        Connection lost. Attempting to reconnect...
                    </div>
                    <button id="manualReconnectBtn" class="secondary">
                        <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor"
                            viewBox="0 0 16 16">
                            <path fill-rule="evenodd"
                                d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2v1z" />
                            <path
                                d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466z" />
                        </svg>
                        Reconnect Now
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div id="notification" class="notification">
        <div class="notification-icon"></div>
        <div class="notification-content"></div>
    </div>

    <footer>
        <p>Advanced WebRTC Audio Room &copy; 2023 | Secure peer-to-peer communication</p>
    </footer>

    <script>
        // Configuration
        const config = {
            reconnectAttempts: 5,
            reconnectInterval: 3000,
            iceServers: [
                { urls: "stun:stun.l.google.com:19302" },
                { urls: "stun:stun1.l.google.com:19302" },
                // Add TURN servers here for production
                // {
                //   urls: "turn:your-turn-server.com",
                //   username: "username",
                //   credential: "credential"
                // }
            ],
            sdpConstraints: {
                mandatory: {
                    OfferToReceiveAudio: true,
                    OfferToReceiveVideo: false
                }
            }
        };

        // DOM Elements
        const $ = id => document.getElementById(id);
        const callBtn = $("callBtn");
        const hangupBtn = $("hangupBtn");
        const remoteAudio = $("remoteAudio");
        const connectionStatus = $("connectionStatus");
        const statusText = $("statusText");
        const roomName = $("roomName");
        const userName = $("userName");
        const usersList = $("usersList");
        const reconnectPanel = $("reconnectPanel");
        const manualReconnectBtn = $("manualReconnectBtn");
        const notification = $("notification");
        const qualityBar = $("qualityBar");
        const iceConnectionState = $("iceConnectionState");
        const signalingState = $("signalingState");
        const connectionState = $("connectionState");

        // State variables
        let pc = null;
        let localStream = null;
        let ws = null;
        let reconnectCount = 0;
        let reconnectTimer = null;
        let isReconnecting = false;
        // Parse roomId and userName from URL
        const urlParams = new URLSearchParams(window.location.search);
        let roomId = window.location.pathname.split('/').pop() || "default";
        let currentUser = urlParams.get("userName") || "Anonymous";
        $("yourUserName").textContent = currentUser;
        let users = new Map();
        let pingInterval = null;

        // Initialize
        init();

        function init() {
            setupWebSocket();
            setupEventListeners();
            updateUI();
        }

        function setupWebSocket() {
            const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
            ws = new WebSocket(`${protocol}//${location.host}`);

            ws.onopen = onWebSocketOpen;
            ws.onmessage = onWebSocketMessage;
            ws.onclose = onWebSocketClose;
            ws.onerror = onWebSocketError;
        }

        function setupEventListeners() {
            callBtn.addEventListener('click', startCall);
            hangupBtn.addEventListener('click', hangUp);
            manualReconnectBtn.addEventListener('click', manualReconnect);

            window.addEventListener('beforeunload', () => {
                sendGoodbye();
                cleanup();
            });

            window.addEventListener('online', () => {
                showNotification('Internet connection restored', 'success');
                attemptReconnect();
            });

            window.addEventListener('offline', () => {
                showNotification('Internet connection lost', 'error');
            });
        }

        function onWebSocketOpen() {
            setConnectionStatus('connected');
            showNotification('Connected to signaling server', 'success');

            // Join the room
            ws.send(JSON.stringify({
                type: "join",
                room: roomId,
                user: currentUser
            }));

            // Request user list
            requestUserList();

            // Start ping to keep connection alive
            startPing();

            // Reset reconnect state
            reconnectCount = 0;
            isReconnecting = false;
            reconnectPanel.style.display = 'none';
        }

        function onWebSocketMessage(event) {
            let msg;
            try {
                msg = JSON.parse(event.data);
            } catch (e) {
                console.error('Failed to parse WebSocket message:', e);
                return;
            }

            switch (msg.type) {
                case "room-status":
                    handleRoomStatus(msg);
                    break;
                case "peer-joined":
                    handlePeerJoined(msg);
                    break;
                case "peer-left":
                    handlePeerLeft(msg);
                    break;
                case "offer":
                    handleOffer(msg);
                    break;
                case "answer":
                    handleAnswer(msg);
                    break;
                case "ice":
                    handleIceCandidate(msg);
                    break;
                case "listeners-list":
                    updateUserList(msg.users);
                    break;
                case "room-full":
                    handleRoomFull();
                    break;
                case "pong":
                    // Connection is alive
                    break;
                case "error":
                    showNotification(msg.message, 'error');
                    break;
                default:
                    console.log('Unknown message type:', msg.type);
            }
        }

        function onWebSocketClose(event) {
            setConnectionStatus('disconnected');
            stopPing();

            if (!event.wasClean && reconnectCount < config.reconnectAttempts) {
                attemptReconnect();
            }
        }

        function onWebSocketError(error) {
            console.error('WebSocket error:', error);
            setConnectionStatus('error');
        }

        function attemptReconnect() {
            if (isReconnecting) return;

            isReconnecting = true;
            reconnectPanel.style.display = 'flex';

            if (reconnectCount >= config.reconnectAttempts) {
                showNotification('Failed to reconnect after multiple attempts', 'error');
                return;
            }

            reconnectCount++;
            showNotification(`Attempting to reconnect (${reconnectCount}/${config.reconnectAttempts})`, 'warning');

            clearTimeout(reconnectTimer);
            reconnectTimer = setTimeout(() => {
                setupWebSocket();
            }, config.reconnectInterval);
        }

        function manualReconnect() {
            reconnectCount = 0;
            attemptReconnect();
        }

        function startPing() {
            clearInterval(pingInterval);
            pingInterval = setInterval(() => {
                if (ws && ws.readyState === WebSocket.OPEN) {
                    ws.send(JSON.stringify({ type: "ping" }));
                }
            }, 30000);
        }

        function stopPing() {
            clearInterval(pingInterval);
        }

        async function startCall() {
            try {
                callBtn.disabled = true;
                setStatusText('Starting call...');

                // Get local audio stream
                localStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });

                // Create peer connection
                pc = createPeerConnection();

                // Add local stream to connection
                localStream.getTracks().forEach(track => {
                    pc.addTrack(track, localStream);
                });

                // Create offer
                const offer = await pc.createOffer(config.sdpConstraints);
                await pc.setLocalDescription(offer);

                // Send offer to signaling server
                ws.send(JSON.stringify({
                    type: "offer",
                    offer: offer
                }));

                setStatusText('Calling...');

            } catch (error) {
                console.error('Error starting call:', error);
                showNotification('Failed to start call: ' + error.message, 'error');
                callBtn.disabled = false;
                cleanup();
            }
        }

        async function handleOffer(msg) {
            if (pc && pc.signalingState !== 'stable') {
                console.log('Cannot handle offer, signaling state is not stable');
                return;
            }

            try {
                setStatusText('Incoming call...');

                // Get local audio stream
                localStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true
                    }
                });

                // Create peer connection
                pc = createPeerConnection();

                // Add local stream to connection
                localStream.getTracks().forEach(track => {
                    pc.addTrack(track, localStream);
                });

                // Set remote description
                await pc.setRemoteDescription(new RTCSessionDescription(msg.offer));

                // Create answer
                const answer = await pc.createAnswer();
                await pc.setLocalDescription(answer);

                // Send answer to signaling server
                ws.send(JSON.stringify({
                    type: "answer",
                    answer: answer
                }));

                hangupBtn.disabled = false;
                setStatusText('Call connected');

            } catch (error) {
                console.error('Error handling offer:', error);
                showNotification('Failed to handle incoming call: ' + error.message, 'error');
                cleanup();
            }
        }

        async function handleAnswer(msg) {
            if (!pc) return;

            try {
                await pc.setRemoteDescription(new RTCSessionDescription(msg.answer));
                setStatusText('Call connected');
                hangupBtn.disabled = false;
            } catch (error) {
                console.error('Error handling answer:', error);
                showNotification('Failed to establish call: ' + error.message, 'error');
                cleanup();
            }
        }

        async function handleIceCandidate(msg) {
            if (!pc || !msg.candidate) return;

            try {
                await pc.addIceCandidate(new RTCIceCandidate(msg.candidate));
            } catch (error) {
                console.error('Error adding ICE candidate:', error);
            }
        }

        function hangUp() {
            sendGoodbye();
            cleanup();
            setStatusText('Call ended');
            hangupBtn.disabled = true;
            callBtn.disabled = false;

            // Notify the server we hung up
            ws.send(JSON.stringify({ type: "hangup" }));
        }

        function sendGoodbye() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: "goodbye" }));
            }
        }

        function cleanup() {
            if (pc) {
                pc.close();
                pc = null;
            }

            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }

            remoteAudio.srcObject = null;
        }

        function createPeerConnection() {
            const pc = new RTCPeerConnection({
                iceServers: config.iceServers
            });

            // Set up event handlers for the peer connection
            pc.onicecandidate = (event) => {
                if (event.candidate) {
                    ws.send(JSON.stringify({
                        type: "ice",
                        candidate: event.candidate
                    }));
                }
            };

            pc.ontrack = (event) => {
                remoteAudio.srcObject = event.streams[0];
                setStatusText('Call active');
            };

            pc.oniceconnectionstatechange = () => {
                updateConnectionState();
            };

            pc.onconnectionstatechange = () => {
                updateConnectionState();
            };

            pc.onsignalingstatechange = () => {
                updateConnectionState();
            };

            return pc;
        }

        function updateConnectionState() {
            if (!pc) return;

            iceConnectionState.textContent = `ICE state: ${pc.iceConnectionState}`;
            signalingState.textContent = `Signaling state: ${pc.signalingState}`;
            connectionState.textContent = `Connection state: ${pc.connectionState}`;

            // Update quality indicator based on connection state
            let quality = 0;
            switch (pc.iceConnectionState) {
                case 'connected':
                    quality = 100;
                    break;
                case 'completed':
                    quality = 100;
                    break;
                case 'checking':
                    quality = 30;
                    break;
                case 'connected':
                    quality = 80;
                    break;
                default:
                    quality = 0;
            }

            qualityBar.style.width = `${quality}%`;

            if (pc.iceConnectionState === 'disconnected' ||
                pc.iceConnectionState === 'failed') {
                setStatusText('Connection lost');
                showNotification('Connection to peer lost', 'error');
            }
        }

        function handleRoomStatus(msg) {
            showNotification(`You joined room: ${msg.room}`, 'success');
            roomName.textContent = msg.room;
        }

        function handlePeerJoined(msg) {
            showNotification(`Peer joined: ${msg.user}`, 'success');
            requestUserList();
        }

        function handlePeerLeft(msg) {
            showNotification('Peer left the call', 'warning');
            cleanup();
            hangupBtn.disabled = true;
            callBtn.disabled = false;
            requestUserList();
        }

        function handleRoomFull() {
            showNotification('Room is full. Cannot join.', 'error');
        }

        function requestUserList() {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify({ type: "listeners" }));
            }
        }

        function updateUserList(userArray) {
            usersList.innerHTML = '';
            users.clear();



            // Add current user first
            const currentUserItem = document.createElement('li');
            currentUserItem.className = 'user-item';
            currentUserItem.innerHTML = `
                <div class="user-status user-online"></div>
                <div class="user-you">${currentUser} (You)</div>
            `;
            usersList.appendChild(currentUserItem);

            // Add other users
            userArray.forEach(user => {
                if (user !== currentUser) {
                    const userItem = document.createElement('li');
                    userItem.className = 'user-item';
                    userItem.innerHTML = `
                        <div class="user-status user-online"></div>
                        <div>${user}</div>
                    `;
                    usersList.appendChild(userItem);
                }
            });

            if (userArray.length === 0) {
                usersList.innerHTML = '<li class="user-item">No other users in room</li>';
            }
        }

        function setConnectionStatus(status) {
            connectionStatus.className = 'status-icon';

            switch (status) {
                case 'connected':
                    connectionStatus.classList.add('status-connected');
                    statusText.textContent = 'Connected';
                    break;
                case 'connecting':
                    connectionStatus.classList.add('status-connecting');
                    statusText.textContent = 'Connecting...';
                    break;
                case 'disconnected':
                    connectionStatus.classList.add('status-disconnected');
                    statusText.textContent = 'Disconnected';
                    break;
                case 'error':
                    connectionStatus.classList.add('status-disconnected');
                    statusText.textContent = 'Connection Error';
                    break;
            }
        }

        function setStatusText(text) {
            statusText.textContent = text;
        }

        function showNotification(message, type) {
            const notification = $("notification");
            const content = notification.querySelector('.notification-content');
            const icon = notification.querySelector('.notification-icon');

            content.textContent = message;
            notification.className = 'notification';

            switch (type) {
                case 'success':
                    notification.classList.add('notification-success');
                    icon.innerHTML = '✓';
                    break;
                case 'warning':
                    notification.classList.add('notification-warning');
                    icon.innerHTML = '⚠';
                    break;
                case 'error':
                    notification.classList.add('notification-error');
                    icon.innerHTML = '✗';
                    break;
            }

            notification.classList.add('show');

            setTimeout(() => {
                notification.classList.remove('show');
            }, 3000);
        }

        function updateUI() {
            roomName.textContent = roomId;
            userName.textContent = currentUser;
        }
    </script>
</body>

</html>